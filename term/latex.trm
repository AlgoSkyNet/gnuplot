/* Hello, Emacs, this is -*-C-*- */

/* GNUPLOT - latex.trm */

/*[
 * Copyright 1990 - 1993, 1998, 2004, 2018
 *
 * Permission to use, copy, and distribute this software and its
 * documentation for any purpose with or without fee is hereby granted,
 * provided that the above copyright notice appear in all copies and
 * that both that copyright notice and this permission notice appear
 * in supporting documentation.
 *
 * Permission to modify the software is granted, but not the right to
 * distribute the complete modified source code.  Modifications are to
 * be distributed as patches to the released version.  Permission to
 * distribute binaries produced by compiling modified sources is granted,
 * provided you
 *   1. distribute the corresponding source modifications from the
 *    released version in the form of a patch file along with the binaries,
 *   2. add special version identification to distinguish your version
 *    in addition to the base release version number,
 *   3. provide your name and address as the primary contact for the
 *    support of your modified version, and
 *   4. retain our contact information in regard to use of the base
 *    software.
 * Permission to distribute the released version of the source code along
 * with corresponding source modifications in the form of a patch file is
 * granted with same provisions 2 through 4 for binary distributions.
 *
 * This software is provided "as is" without express or implied warranty
 * to the extent permitted by applicable law.
]*/

/*
 * This file is included by ../term.c.
 *
 * This terminal driver supports:
 *   LaTeX pictures (latex).
 *   LaTeX pictures with emTeX \specials (emtex).
 *   LaTeX pictures with tpic \specials (version 2.2).
 *   LaTeX pictures with eepic macros.
 *   LaTeX2e picture (pict2e).
 *
 * AUTHORS
 *   David Kotz, Russell Lang (latex/emtex)
 *   Oh-Yeah?   3 Sep. 1992 (tpic)
 *   David Kotz (eepic)
 *   Bastian Maerkisch (pict2e)
 *
 * send your comments or suggestions to (gnuplot-info@lists.sourceforge.net).
 *
 */

/* modified to optimize use of \rule for long lines */
/* TLDC: modified to have nice line types */

/* the following LATEX driver has been modified by
   Russell Lang, eln272v@monu1.cc.monash.oz from the
   GnuTeX 1.3 driver by David Kotz, David.Kotz@Dartmouth.edu.
   Since then it has been further extended by David Kotz.
   EmTeX driver by Russell Lang. */

/*  9 Dec 1992  LATEX_put_text rewritten to handle \\ newlines
                Daniel S. Lewart (d-lewart@uiuc.edu) */

/* Since it took me a little while to figure out what is happening,
 * I may as well write it down.
 *  There are three length scales of interest: inches, points
 * and dots. inches are obvious. points are the usual typesetting
 * thing (ie approx 72 points per inch). This driver works in
 * units of dots, which corresponds to pixels on a 300 DPI printer.
 * We do a \setlength{unitlength}{...pt} to make teX work in
 * terms of dots.  The ... is called LATEX_UNIT in here.
 *   The reason I had to get involved in all of this is because
 * font size (in pts) was not being scaled up by DOTS_PER_POINT
 * - drd, Sept 1996
 */

/* E A Merritt Feb 2007 - change sequence of point types to match
 * PostScript and other terminals. Uses symbols from amssymb package.
 */

/* T.Sefzick Oct 2009 - rotate text when option 'rotated' is given.
 * needs graphics or graphicx package.
 */

/* B. Maerkisch May 2018 - merge the very similar latex, emtex, tpic
 * and eepic terminals into one.  Add a new variant for the LaTeX2e
 * pict2e package. Point symbols, color and text functions are
 * identical for all variants. Only line drawing (vector/dashtype/
 * linewidth) and filled polygons and boxes differ.
 * This merge makes line types and point symbols equal for all variants,
 * i.e. specialities of the eepic and tpic variants are lost. This is OK
 * though since v5 now gives you the possibility to redefine line types
 * at will.
 */

#include "driver.h"

#ifdef TERM_REGISTER
register_term(latex)
#endif

#ifdef TERM_PROTO
TERM_PUBLIC void LATEX_options(void);
TERM_PUBLIC void LATEX_init(void);
TERM_PUBLIC void LATEX_graphics(void);
TERM_PUBLIC void LATEX_text(void);
TERM_PUBLIC void LATEX_put_text(unsigned int x, unsigned int y, const char str[]);
TERM_PUBLIC void LATEX_linetype(int linetype);
TERM_PUBLIC void LATEX_move(unsigned int x, unsigned int y);
TERM_PUBLIC void LATEX_point(unsigned int x, unsigned int y, int number);
TERM_PUBLIC void LATEX_vector(unsigned int ux, unsigned int uy);
TERM_PUBLIC void LATEX_arrow(unsigned int sx, unsigned int sy, unsigned int ex, unsigned int ey, int head);
TERM_PUBLIC int LATEX_justify_text(enum JUSTIFY mode);
TERM_PUBLIC int LATEX_text_angle(int ang);
TERM_PUBLIC void LATEX_reset(void);
TERM_PUBLIC void LATEX_fillbox(int style, unsigned int x1, unsigned int y1,
					unsigned int width, unsigned int height);
TERM_PUBLIC int LATEX_make_palette(t_sm_palette *palette);
TERM_PUBLIC void LATEX_set_color(t_colorspec *colorspec);
TERM_PUBLIC void TPIC_fillbox(int style,
		unsigned int x1, unsigned int y1,
		unsigned int width, unsigned int height);
TERM_PUBLIC void TPIC_filled_polygon(int points, gpiPoint *corners);
TERM_PUBLIC void EEPIC_fillbox(int style,
		unsigned int x1, unsigned int y1,
		unsigned int width, unsigned int height);
TERM_PUBLIC void EEPIC_filled_polygon(int points, gpiPoint *corners);
TERM_PUBLIC void PICT2E_fillbox(int style,
		unsigned int x1, unsigned int y1,
		unsigned int width, unsigned int height);
TERM_PUBLIC void PICT2E_filled_polygon(int points, gpiPoint *corners);


#define TINY_STEP 0.5		/* tiny steps for high quality lines */

#define LATEX_PTS_PER_INCH (72.27)
#define DOTS_PER_INCH (300)	/* resolution of printer we expect to use */
#define LATEX_UNIT (LATEX_PTS_PER_INCH/DOTS_PER_INCH)	/* dot size in pt */

/* 5 inches wide by 3 inches high (default) */
#define LATEX_XMAX (5*DOTS_PER_INCH)	/* (LATEX_PTS_PER_INCH/LATEX_UNIT*5.0) */
#define LATEX_YMAX (3*DOTS_PER_INCH)	/* (LATEX_PTS_PER_INCH/LATEX_UNIT*3.0) */

#define LATEX_HTIC (5*DOTS_PER_INCH/72)		/* (5 pts) */
#define LATEX_VTIC (5*DOTS_PER_INCH/72)		/* (5 pts) */
#define LATEX_HCHAR (DOTS_PER_INCH*53/10/72)	/* (5.3 pts) */
#define LATEX_VCHAR (DOTS_PER_INCH*11/72)	/* (11 pts) */

/* tpic \specials unit in inches (1 milli-inch) */
#define TPIC_UNIT 0.001
#endif


#ifndef TERM_PROTO_ONLY
#ifdef TERM_BODY

static int LATEX_posx;
static int LATEX_posy;
static int LATEX_fontsize = 10;
static char LATEX_font[MAX_ID_LEN+1] = "doc";
static enum JUSTIFY latex_justify = LEFT;
static int latex_angle = 0;
static TBOOLEAN latex_rotate = FALSE;

static TBOOLEAN latex_explicit_size = FALSE;
static size_units latex_explicit_units = INCHES;

/* Default line-drawing character */
/* the definition of plotpoint varies with linetype */
#define LATEX_DOT "\\usebox{\\plotpoint}"
#define LATEX_TINY_DOT "\\rule{1pt}{1pt}"	/* for dots plot style */

/* COLORS */
static TBOOLEAN latex_use_color = FALSE; /* LATEX terminal option */
static char latex_color[32] = "";
#define LATEX_num_colors 6
static const char * LATEX_lt_colors[] = {
    "red", "green", "blue", "magenta", "cyan", "yellow"
};

/* POINTS */
#define LATEX_POINT_TYPES 15	/* we supply more point types */
static int LATEX_pointsize = 0;
static const char * LATEX_points[LATEX_POINT_TYPES] = {
    "\\makebox(0,0){$%s+$}",
    "\\makebox(0,0){$%s\\times$}",
    "\\makebox(0,0){$%s\\ast$}",
    "\\raisebox{-.8pt}{\\makebox(0,0){$%s\\Box$}}",
    "\\makebox(0,0){$%s\\blacksquare$}",
    "\\makebox(0,0){$%s\\circ$}",
    "\\makebox(0,0){$%s\\bullet$}",
    "\\makebox(0,0){$%s\\triangle$}",
    "\\makebox(0,0){$%s\\blacktriangle$}",
    "\\makebox(0,0){$%s\\triangledown$}",
    "\\makebox(0,0){$%s\\blacktriangledown$}",
    "\\makebox(0,0){$%s\\lozenge$}",
    "\\makebox(0,0){$%s\\blacklozenge$}",
    "\\makebox(0,0){$%s\\heartsuit$}",
    "\\makebox(0,0){$%s\\spadesuit$}"
};

/* LINES */
static void LATEX_linesize(void);
static float LATEX_size = 0;	/* current thick of line in points */
static float LATEX_lw;
static float LATEX_dotspace = 0;	/* current dotspace of line in points */
#define LATEX_DOT_SPACE 3.0
#define LATEX_LINEMAX 50	/* max value for linecount */
static TBOOLEAN LATEX_inline;	/* are we in the middle of a line */
static int LATEX_linecount = 0;	/* number of points in line so far */
static unsigned int LATEX_path[LATEX_LINEMAX][2];		/* point stack */


static void LATEX_endline(void);

/* for drawing dotted and solid lines */
static void LATEX_dot_line(int x1, int x2, int y1, int y2);
static void LATEX_solid_line(int x1, int x2, int y1, int y2);
static void LATEX_rule(int code, double x, double y, double width, double height);
static void LATEX_flushdot(void);
#define LATEX_flushrule() LATEX_rule(2, 0.,0.,0.,0.)	/* flush old rule */
static TBOOLEAN LATEX_moved = TRUE;	/* pen is up after move */
static float LATEX_dotsize;	/* size of LATEX_DOT in units */
static TBOOLEAN LATEX_needsdot = FALSE;		/* does dotted line need termination? */

static void EMTEX_solid_line(int x1, int x2, int y1, int y2);

static void tpic_startline(void);
static void tpic_endline(void);
static void LATEX_pushpath(unsigned int x, unsigned int y);
static void tpic_scanpath(void);
static void tpic_fill(int style);
static void tpic_path(int x, int y);
static void tpic_flush(void);
static void tpic_abspath(unsigned int x, unsigned int y);	/* absolute coord */
static void tpic_shade(double grayscale);
static void tpic_pen(int thickness);
static void tpic_dottedflush(double interval);
static void tpic_dashedflush(double interval);

const char * EEPIC_line;
#define EEPIC_NUM_PAT 7
static const char * EEPIC_dashpat[EEPIC_NUM_PAT] = {
    "\\path",	/* -2 border */
    "\\drawline[-50]",	/* -1 axes */
    "\\path",	/*  0 solid thin  */
    "\\dashline[90]{10}",
    "\\dottedline{10}",
    "\\dashline[60]{20}",
    "\\dottedline{20}"
};
static void EEPIC_draw_line(int x1, int x2, int y1, int y2);
static void EEPIC_fill(int style); /* fill command for boxes and polygons */


typedef enum {
    tpic_solid, tpic_dotted, tpic_dashed,
    tpic_dashed_sdot, tpic_dashed_ddot
} tpic_linestyle;
static const int tpic_num_pat = 5;
static const tpic_linestyle tpic_pattern[7] = {
	tpic_solid, tpic_dashed,
	tpic_solid, tpic_dashed, tpic_dashed_sdot, tpic_dashed_ddot, tpic_dotted
};
static tpic_linestyle tpic_linetype = tpic_solid;	/* current line type */

static void PICT2E_solid_line(int x1, int x2, int y1, int y2);
static void PICT2E_endline(void);
static int PICT2E_fill(int style);


/* ARROWS */
/* the set of non-vertical/non-horizontal LaTeX vector slopes */
/* except negatives - they are handled specially */
static struct vslope {
    int dx, dy;
} LATEX_slopes[] =

{
    {1, 1},
    {1, 2},
    {1, 3},
    {1, 4},
    {2, 1},
    {2, 3},
    {3, 1},
    {3, 2},
    {3, 4},
    {4, 1},
    {4, 3},
    {0, 0}			/* terminator */
};

/* figure out the best arrow */
static void best_latex_arrow(int, int, int, int, int);

enum LATEX_id {
    LATEX_COURIER, LATEX_ROMAN, LATEX_DEFAULT,
    LATEX_NORMAL, LATEX_SMALL, LATEX_TINY,
    LATEX_SIZE,
    // LATEX_STANDALONE, LATEX_INPUT,
    LATEX_ROTATE, LATEX_NOROTATE,
    LATEX_COLOR, LATEX_MONOCHROME,
    // LATEX_LINEWIDTH, LATEX_POINTSCALE,
    // LATEX_TEXARROWS, LATEX_GPARROWS,
    // LATEX_TEXPOINTS, LATEX_GPPOINTS,
    // LATEX_BACKGROUND,
    LATEX_LATEX, LATEX_EMTEX, LATEX_TPIC, LATEX_EEPIC, LATEX_PICT2E,
    LATEX_OTHER
};
enum LATEX_id LATEX_mode = LATEX_PICT2E;

static struct gen_table LATEX_opts[] =
{
    { "c$ourier", LATEX_COURIER },
    { "r$oman", LATEX_ROMAN },
    { "d$efault", LATEX_DEFAULT },
    { "si$ze", LATEX_SIZE },
    // { "stand$alone", LATEX_STANDALONE },
    // { "inp$ut", LATEX_INPUT },
    { "rot$ate", LATEX_ROTATE },
    { "no$rotate", LATEX_NOROTATE },
    { "color", LATEX_COLOR },
    { "colour", LATEX_COLOR },
    { "mono$chrome", LATEX_MONOCHROME },
    // { "backg$round", LATEX_BACKGROUND },
    // { "lw", LATEX_LINEWIDTH },
    // { "linew$idth", LATEX_LINEWIDTH },
    // { "points$cale", LATEX_POINTSCALE },
    // { "ps", LATEX_POINTSCALE },
    // { "texarrows", LATEX_TEXARROWS },
    // { "gparrows", LATEX_GPARROWS },
    // { "texpoints", LATEX_TEXPOINTS },
    // { "gppoints", LATEX_GPPOINTS },
    { "norm$al", LATEX_NORMAL },
    { "s$mall", LATEX_SMALL },
    { "t$iny", LATEX_TINY },
    { "latex", LATEX_LATEX },
    { "legacy", LATEX_LATEX },
    { "emtex", LATEX_EMTEX },
    { "tpic", LATEX_TPIC },
    { "eepic", LATEX_EEPIC },
    { "pict2e", LATEX_PICT2E },
    { NULL, LATEX_OTHER }
};


TERM_PUBLIC void
LATEX_options()
{
    latex_explicit_size = FALSE;

    // Backward compatibility with previous terminal names
    c_token--; // see how we got here
    // Note that we cannot test for "latex". That's the generic terminal name
    if (equals(c_token, "emtex"))
	LATEX_mode = LATEX_EMTEX;
    else if (equals(c_token, "tpic"))
	LATEX_mode = LATEX_TPIC;
    else if (equals(c_token, "eepic"))
	LATEX_mode = LATEX_EEPIC;
    else if (equals(c_token, "pict2e"))
	LATEX_mode = LATEX_PICT2E;
    c_token++;

    while (!END_OF_COMMAND) {
	enum LATEX_id cmd = (enum LATEX_id) lookup_table(&LATEX_opts[0], c_token);
	switch (cmd) {
	case LATEX_LATEX:
	case LATEX_EMTEX:
	case LATEX_TPIC:
	case LATEX_EEPIC:
	case LATEX_PICT2E:
	    LATEX_mode = cmd;
	    c_token++;
	    break;
	case LATEX_COURIER:
	    strcpy(LATEX_font, "cmtt");
	    c_token++;
	    break;
	case LATEX_ROMAN:
	    strcpy(LATEX_font, "cmr");
	    c_token++;
	    break;
	case LATEX_DEFAULT:
	    strcpy(LATEX_font, "doc");
	    c_token++;
	    break;
	case LATEX_SIZE: {
	    float xmax_t = 5., ymax_t = 3.;
	    c_token++;
	    latex_explicit_size = TRUE;
	    latex_explicit_units = parse_term_size(&xmax_t, &ymax_t, INCHES);
	    term->xmax = xmax_t * DOTS_PER_INCH / 72;
	    term->ymax = ymax_t * DOTS_PER_INCH / 72;
	    break;
	}
	case LATEX_ROTATE:
	    latex_rotate = TRUE;
	    c_token++;
	    break;
	case LATEX_NOROTATE:
	    latex_rotate = FALSE;
	    c_token++;
	    break;
	case LATEX_COLOR:
	    latex_use_color = TRUE;
	    term->flags &= ~TERM_MONOCHROME;
	    c_token++;
	    break;
	case LATEX_MONOCHROME:
	    latex_use_color = FALSE;
	    term->flags |= TERM_MONOCHROME;
	    c_token++;
	    break;
	case LATEX_NORMAL:
	    LATEX_pointsize = 0;
	    c_token++;
	    break;
	case LATEX_SMALL:
	    LATEX_pointsize = 1;
	    c_token++;
	    break;
	case LATEX_TINY:
	    LATEX_pointsize = 2;
	    c_token++;
	    break;
	case LATEX_OTHER:
	default:
	    if (isanumber(c_token)) {
		LATEX_fontsize = int_expression();
		if (LATEX_fontsize <= 1)
		    LATEX_fontsize = 10;
		break;
	    }
	    int_error(c_token, "unrecognized option");
	}
    }

    // Select box and polygon fill functions
    switch (LATEX_mode) {
    case LATEX_LATEX:
    case LATEX_EMTEX:
	term->filled_polygon = NULL;  // not available
	term->fillbox = LATEX_fillbox;
	break;
    case LATEX_TPIC:
	term->filled_polygon = TPIC_filled_polygon;
	term->fillbox = TPIC_fillbox;
	break;
    case LATEX_EEPIC:
	term->filled_polygon = EEPIC_filled_polygon;
	term->fillbox = EEPIC_fillbox;
	break;
    case LATEX_PICT2E:
	term->filled_polygon = PICT2E_filled_polygon;
	term->fillbox = PICT2E_fillbox;
	break;
    default:
	;
    }

    /* tell gnuplot core about char. sizes. Horizontal spacing
     * is about half the text pointsize
     */
    term->v_char = (unsigned int) (LATEX_fontsize * DOTS_PER_INCH / 72);
    term->h_char = (unsigned int) (LATEX_fontsize * DOTS_PER_INCH / 144);

    if (strcmp(LATEX_font, "doc")==0)
	sprintf(term_options, "(document specific font) %d", LATEX_fontsize);
    else
	sprintf(term_options, "%s %d",
		LATEX_font[2] == 't' ? "courier" : "roman", LATEX_fontsize);

    switch (LATEX_mode) {
    case LATEX_LATEX:
	sprintf(&(term_options[strlen(term_options)]), " legacy");
	break;
    case LATEX_EMTEX:
	sprintf(&(term_options[strlen(term_options)]), " emtex");
	break;
    case LATEX_TPIC:
	sprintf(&(term_options[strlen(term_options)]), " tpic");
	break;
    case LATEX_EEPIC:
	sprintf(&(term_options[strlen(term_options)]), " eepic");
	break;
    case LATEX_PICT2E:
	sprintf(&(term_options[strlen(term_options)]), " pict2e");
	break;
    default:
	;
    }

    if (latex_explicit_size) {
	if (latex_explicit_units == CM)
	    sprintf(&(term_options[strlen(term_options)]), "size %.2fcm, %.2fcm ",
		2.54 * (float)term->xmax / (DOTS_PER_INCH),
		2.54 * (float)term->ymax / (DOTS_PER_INCH));
	else
	    sprintf(&(term_options[strlen(term_options)]), "size %.2fin, %.2fin ",
		(float)term->xmax / (DOTS_PER_INCH),
		(float)term->ymax / (DOTS_PER_INCH));
    }

    if (latex_rotate) {
	sprintf(&(term_options[strlen(term_options)]), " rotate");
    } else {
	sprintf(&(term_options[strlen(term_options)]), " norotate");
    }

    if (latex_use_color) {
	sprintf(&(term_options[strlen(term_options)]), " color");
    } else {
	sprintf(&(term_options[strlen(term_options)]), " monochrome");
    }

    sprintf(term_options + strlen(term_options),
	LATEX_pointsize == 1 ? " small" : (LATEX_pointsize == 2 ? " tiny" : " normal"));
}


TERM_PUBLIC void
LATEX_init()
{
    switch (LATEX_mode) {
    case LATEX_LATEX:
	fputs("% GNUPLOT: LaTeX picture\n", gpoutfile);
	break;
    case LATEX_EMTEX:
	fputs("% GNUPLOT: LaTeX picture with emtex specials\n", gpoutfile);
	break;
    case LATEX_TPIC:
	fputs("% GNUPLOT: LaTeX picture with tpic specials\n", gpoutfile);
	break;
    case LATEX_EEPIC:
	fputs("% GNUPLOT: LaTeX picture using EEPIC macros\n", gpoutfile);
	break;
    case LATEX_PICT2E:
	fputs("% GNUPLOT: LaTeX2e picture (pict2e)\n", gpoutfile);
	break;
    default:
	;
    }
    fprintf(gpoutfile, "\
\\setlength{\\unitlength}{%fpt}\n\
\\ifx\\plotpoint\\undefined\\newsavebox{\\plotpoint}\\fi\n",
	    LATEX_UNIT);
}


TERM_PUBLIC void
LATEX_graphics()
{
    /* set size of canvas */
    if (!latex_explicit_size) {
	term->xmax = LATEX_XMAX;
	term->ymax = LATEX_YMAX;
    }

    fprintf(gpoutfile, "\\begin{picture}(%d,%d)(0,0)\n",
	    term->xmax, term->ymax);
    if (strcmp(LATEX_font, "doc") != 0) {
        fprintf(gpoutfile, "\
\\font\\gnuplot=%s10 at %dpt\n\
\\gnuplot\n",
		LATEX_font, LATEX_fontsize);
    }
    // if (eepic_fontsize_set) {
	// float x = term->v_char * EEPIC_UNIT + 0.5;
	// fprintf(gpoutfile, "\\fontsize{%d}{%g}\\selectfont\n",
		// (int) x,  1.2 * x );
    // } else {
	// fprintf(gpoutfile,"\\footnotesize\n" );
    // }
    LATEX_lw = 1;
    LATEX_size = 0;
    latex_color[0] = 0;
    LATEX_linetype(LT_AXIS);
    LATEX_inline = FALSE;
    LATEX_linecount = 0;
    EEPIC_line = "\\path";
    LATEX_posx = LATEX_posy = 0;
}


TERM_PUBLIC void
LATEX_text()
{
    LATEX_endline();
    fputs("\\end{picture}\n", gpoutfile);
    LATEX_posx = LATEX_posy = 0;	/* current position */
    LATEX_moved = TRUE;		/* pen is up after move */
}


TERM_PUBLIC void
LATEX_reset()
{
    LATEX_posx = LATEX_posy = 0;	/* current position */
    LATEX_moved = TRUE;		/* pen is up after move */
}


static void
LATEX_linesize(void)
{
    float size;

    LATEX_endline();

    /* Find the new desired line thickness. */
    size = LATEX_lw * 0.4;

    /* If different from current size, redefine \plotpoint */
    if (size != LATEX_size) {
	fprintf(gpoutfile,
		"\\sbox{\\plotpoint}{\\rule[%.3fpt]{%.3fpt}{%.3fpt}}%%\n",
		-size / 2, size, size);
	if (LATEX_mode == LATEX_EMTEX)		/* change line width */
	    fprintf(gpoutfile, "\\special{em:linewidth %.1fpt}%%\n", size);
	else if (LATEX_mode == LATEX_EEPIC)
	    fprintf(gpoutfile, "\\allinethickness{%.1fpt}\n", size);
	else if (LATEX_mode == LATEX_PICT2E)
	    fprintf(gpoutfile, "\\linethickness{%.1fpt}%%\n", size);
    }
    LATEX_size = size;
    LATEX_dotsize = size / LATEX_UNIT;
    LATEX_moved = TRUE;		/* reset */
}


TERM_PUBLIC void
LATEX_linetype(int linetype)
{
    t_colorspec colorspec;

    LATEX_endline();

    /* save values for set_color */
    colorspec.type = TC_LT;
    colorspec.lt = linetype;

    LATEX_linesize();
    LATEX_set_color(&colorspec);

    /* all but axis lines are solid by default */
    if (linetype == LT_AXIS) {
	LATEX_dotspace = LATEX_DOT_SPACE;
	tpic_linetype = tpic_dashed;
	EEPIC_line = EEPIC_dashpat[1]; // dashed line
    } else {
	LATEX_dotspace = 0.0;
	tpic_linetype = tpic_solid;
	EEPIC_line = EEPIC_dashpat[2]; // solid line
    }
}


TERM_PUBLIC void
LATEX_dashtype(int dt, t_dashtype *custom_dash_pattern)
{
    switch (LATEX_mode) {
    case LATEX_LATEX:
    case LATEX_EMTEX:
    case LATEX_PICT2E:
	if (dt >= 0) {
	    int linetype = dt % 3;
	    LATEX_dotspace = LATEX_DOT_SPACE * linetype;
	} else if (dt == DASHTYPE_SOLID) {
	    LATEX_dotspace = 0.0;
	} else if (dt == DASHTYPE_AXIS) {
	    LATEX_dotspace = LATEX_DOT_SPACE;
	} else if (dt == DASHTYPE_CUSTOM) {
	    /* not supported */
	}
	break;
    case LATEX_TPIC:
	if (dt >= 0) {
	    if (dt >= tpic_num_pat + LT_BLACK)
		dt %= (tpic_num_pat + LT_BLACK);
	    tpic_linetype = tpic_pattern[dt - LT_BLACK];
	} else if (dt == DASHTYPE_SOLID) {
	    tpic_linetype= tpic_pattern[0];
	} else if (dt == DASHTYPE_AXIS) {
	    tpic_linetype =  tpic_pattern[1];
	} else if (dt == DASHTYPE_CUSTOM) {
	    /* not supported */
	}
	break;
    case LATEX_EEPIC:
	if (dt >= 0) {
	    if (dt >= EEPIC_NUM_PAT + LT_BLACK)
		dt %= (EEPIC_NUM_PAT + LT_BLACK);
	    EEPIC_line = EEPIC_dashpat[dt - LT_BLACK];
	} else if (dt == DASHTYPE_SOLID) {
	    EEPIC_line = EEPIC_dashpat[0];
	} else if (dt == DASHTYPE_AXIS) {
	    EEPIC_line = EEPIC_dashpat[1];
	} else if (dt == DASHTYPE_CUSTOM) {
	    /* not supported */
	}
	break;
    default:
	;
    }
}


TERM_PUBLIC void
LATEX_linewidth(double linewidth)
{
    LATEX_lw = linewidth;
}


TERM_PUBLIC void
LATEX_move(unsigned int x, unsigned int y)
{
    LATEX_endline();

    LATEX_posx = x;
    LATEX_posy = y;
    LATEX_moved = TRUE;		/* reset */
}


TERM_PUBLIC void
LATEX_point(unsigned int x, unsigned int y, int number)
{
    const char * size[] = { "", "\\scriptstyle", "\\scriptscriptstyle" };
    char point[80];

    LATEX_move(x, y);

    /* Print the character defined by 'number'; number < 0 means
       to use a dot, otherwise one of the defined points. */
    if (number >= 0)
	snprintf(point, sizeof(point), LATEX_points[number % LATEX_POINT_TYPES], size[LATEX_pointsize]);
    fprintf(gpoutfile, "\\put(%d,%d){%s}\n", x, y,
	    (number < 0 ? LATEX_TINY_DOT : point));
}


static void
LATEX_endline(void)
{
    switch (LATEX_mode) {
    case LATEX_LATEX:
	LATEX_flushrule();
	LATEX_flushdot();
	break;
    case LATEX_TPIC:
	tpic_endline();
	break;
    case LATEX_EEPIC:
	if (LATEX_inline) {
	    LATEX_inline = FALSE;
	    fputs("\n", gpoutfile);
	}
	break;
    case LATEX_PICT2E:
	PICT2E_endline();
	LATEX_flushdot();
	break;
    default:
	;
    }
}


static void
LATEX_pushpath(unsigned int x, unsigned int y)
{
    if (LATEX_linecount < LATEX_LINEMAX) {
	LATEX_path[LATEX_linecount][0] = x;
	LATEX_path[LATEX_linecount][1] = y;
	LATEX_linecount++;
    }
    return;
}


TERM_PUBLIC void
LATEX_vector(unsigned int ux, unsigned int uy)
{
    switch (LATEX_mode) {
    case LATEX_LATEX:
	if (LATEX_dotspace == 0.0)
	    LATEX_solid_line(LATEX_posx, (int) ux, LATEX_posy, (int) uy);
	else
	    LATEX_dot_line(LATEX_posx, (int) ux, LATEX_posy, (int) uy);
	break;
    case LATEX_EMTEX:
	if (LATEX_dotspace == 0.0)
	    EMTEX_solid_line(LATEX_posx, (int) ux, LATEX_posy, (int) uy);
	else
	    LATEX_dot_line(LATEX_posx, (int) ux, LATEX_posy, (int) uy);
	break;
    case LATEX_TPIC:
	if (!LATEX_inline) {
	    tpic_startline();
	} else if (LATEX_linecount >= LATEX_LINEMAX) {
	    /* Even though we are in the middle of a path, we may start a new path
	       command once in a while; if they are too long, latex will choke. */
	    tpic_endline();
	    tpic_startline();
	}
	LATEX_pushpath(ux, uy);
	break;
    case LATEX_EEPIC:
	EEPIC_draw_line(LATEX_posx, (int) ux, LATEX_posy, (int) uy);
	break;
    case LATEX_PICT2E:
	if (LATEX_dotspace == 0.0)
	    PICT2E_solid_line(LATEX_posx, (int) ux, LATEX_posy, (int) uy);
	else
	    LATEX_dot_line(LATEX_posx, (int) ux, LATEX_posy, (int) uy);
	break;
    default:
	;
    }

    LATEX_posx = ux;
    LATEX_posy = uy;
}


static void
LATEX_solid_line(int x1, int x2, int y1, int y2)
{
    float slope;
    int inc;
    float dx, dy, x, y;
    float offset, length;
    int code;			/* possibly combine with previous rule */

    /* we draw a solid line using the current line thickness (size) */
    /* we do it with lots of \\rules */

    if (x1 == x2 && y1 == y2) {	/* zero-length line - just a dot */
	if (LATEX_moved) {
	    LATEX_flushrule();
	    /* plot a dot */
	    fprintf(gpoutfile, "\\put(%u,%u){%s}\n", x1, y1, LATEX_DOT);
	}
    } else {
	code = (LATEX_moved ? 0 : 1);	/* no combine after move */
	LATEX_moved = FALSE;
	if (x1 == x2)		/* vertical line - special case */
	    LATEX_rule(code, (double) x1, (double) y1,
		       LATEX_dotsize, (double) y2 - y1);
	else if (y1 == y2)	/* horizontal line - special case */
	    LATEX_rule(code, (double) x1, (double) y1, (double) x2 - x1,
		       LATEX_dotsize);
	else {
	    dx = (float) x2 - x1;
	    dy = (float) y2 - y1;
	    slope = dy / dx;
	    if (ABS(slope) <= 1.0) {
		/* longer than high */
		x = GPMIN(ABS(dx), (0.25 + 1.0 / ABS(slope)) * LATEX_dotsize);
		offset = sign(dy) * GPMIN(LATEX_dotsize, ABS(dy));
		dy = dy - offset;
		length = x * LATEX_UNIT;
		inc = (x == ABS(dx) ? 1 : GPMAX(1, ABS(dy) / TINY_STEP + 0.5));
		if (inc == 1) {
		    fprintf(gpoutfile, "\\put(%u,%.2f){\\rule{%.3fpt}{%.3fpt}}\n",
			    (x2 >= x1 ? x1 : x2), ((float) y1 + y2 - LATEX_dotsize) / 2,
			    length, LATEX_dotsize * LATEX_UNIT);
		} else {
		    dy = dy / inc;
		    dx = (dx - sign(dx) * x) / (inc - 1);
		    fprintf(gpoutfile,
			    "\\multiput(%.2f,%.2f)(%.3f,%.3f){%u}{\\rule{%.3fpt}{%.3fpt}}\n",
			    (dx >= 0.0 ? (float) x1 : x1 - x),
			    (float) y1 - (ABS(dy) - offset) / 2,
			    dx, dy, inc, length, ABS(dy) * LATEX_UNIT);
		}
/* done with one section, now smooth it */
		x = x / 2;
		dx = sign(dx) * x;
		dx = (float) x2 - x1 - dx;
		dy = (float) y2 - y1;
		fprintf(gpoutfile, "\\multiput(%.2f,%.2f)(%.3f,%.3f){2}{\\rule{%.3fpt}{%.3fpt}}\n",
			(dx >= 0.0 ? (float) x1 : x1 - x), (float) y1 - LATEX_dotsize / 2,
			dx, dy, x * LATEX_UNIT, LATEX_dotsize * LATEX_UNIT);
		LATEX_moved = TRUE;
	    } else {
		/* higher than long */
		y = GPMIN(ABS(dy), (0.25 + ABS(slope)) * LATEX_dotsize);
		offset = sign(dx) * GPMIN(LATEX_dotsize, ABS(dx));
		dx = dx - offset;
		length = y * LATEX_UNIT;
		inc = (y == ABS(dy) ? 1 : GPMAX(1, ABS(dx) / TINY_STEP + 0.5));
		if (inc == 1) {
		    fprintf(gpoutfile, "\\put(%.2f,%u){\\rule{%.3fpt}{%.3fpt}}\n",
			    ((float) x1 + x2 - LATEX_dotsize) / 2, (y2 >= y1 ? y1 : y2),
			    LATEX_dotsize * LATEX_UNIT, length);
		} else {
		    dx = dx / inc;
		    dy = (dy - sign(dy) * y) / (inc - 1);
		    fprintf(gpoutfile,
			    "\\multiput(%.2f,%.2f)(%.3f,%.3f){%u}{\\rule{%.3fpt}{%.3fpt}}\n",
			    (float) x1 - (ABS(dx) - offset) / 2,
			    (dy >= 0 ? (float) y1 : y1 - y),
			    dx, dy, inc, ABS(dx) * LATEX_UNIT, length);
		}
/* done with one section, now smooth it */
		y = y / 2;
		dx = (float) x2 - x1;
		dy = sign(dy) * y;
		dy = (float) y2 - y1 - dy;
		fprintf(gpoutfile, "\\multiput(%.2f,%.2f)(%.3f,%.3f){2}{\\rule{%.3fpt}{%.3fpt}}\n",
			(float) x1 - LATEX_dotsize / 2, (dy >= 0.0 ? (float) y1 : y1 - y),
			dx, dy, LATEX_dotsize * LATEX_UNIT, y * LATEX_UNIT);
		LATEX_moved = TRUE;
	    }
	}
    }
}


/* Draw a \rule. Width or height may be negative; we can correct.
 * The rule is never output immediately. The previous rule is output
 * as-is if code is 0, and the previous rule is
 * combined with the current rule (if possible) if code is 1.
 * The previous rule is output, and the new one ignored, if code is 2.
 */
static void
LATEX_rule(
    int code,			/* how do we treat this rule? */
    double x, double y,
    double width,
    double height)
{
    static float lastx, lasty;
    static float lastw, lasth;
    static TBOOLEAN isvalid = FALSE;	/* is 'last' data valid? */
    TBOOLEAN combine = (code == 1);
    TBOOLEAN flush = (code == 2);

    if (!flush)
	if (width == 0 || height == 0)
	    return;		/* ignore this rule */

    if (isvalid && combine) {
	/* try to combine new rule with old rule */
	if ((int) lastx == (int) x && lastw == width) {		/* vertical rule */
	    if (lasth * height >= 0) {	/* same sign */
		lasth += height;
		return;
	    }
	} else if ((int) lasty == (int) y && lasth == height) {		/* horiz rule */
	    if (lastw * width >= 0) {	/* same sign */
		lastw += width;
		return;
	    }
	}
	/* oh well, output last and remember the new one */
    }
    if (isvalid) {
	/* output the rule */
	if (lastw < 0) {
	    lastx += lastw;
	    lastw = -lastw;
	}
	if (lasth < 0) {
	    lasty += lasth;
	    lasth = -lasth;
	}
	/* if very small use canned dot */
	if (lastw < LATEX_dotsize || lasth < LATEX_dotsize)
	    fprintf(gpoutfile, "\\put(%.1f,%.1f){%s}\n",
		    lastx, lasty, LATEX_DOT);
	else
	    fprintf(gpoutfile, "\\put(%.1f,%.1f){\\rule[%.3fpt]{%.3fpt}{%.3fpt}}\n",
		    lastx, lasty, -LATEX_dotsize * LATEX_UNIT / 2,
		    lastw * LATEX_UNIT, lasth * LATEX_UNIT);
    }
    if (flush) {
	isvalid = FALSE;
    } else {
	lastx = x;
	lasty = y;
	lastw = width;
	lasth = height;
	isvalid = TRUE;
    }
}


static void
LATEX_dot_line(int x1, int x2, int y1, int y2)
{
    static float LATEX_left;	/* fraction of space left after last dot */

    /* we draw a dotted line using the current dot spacing */

    if (LATEX_moved)
	LATEX_left = 1.0;	/* reset after a move */

    /* zero-length line? */
    if (x1 == x2 && y1 == y2) {
	if (LATEX_moved)
	    /* plot a dot */
	    fprintf(gpoutfile, "\\put(%u,%u){%s}\n", x1, y1, LATEX_DOT);
    } else {
	float dotspace = LATEX_dotspace / LATEX_UNIT;
	float x, y;		/* current position */
	float xinc, yinc;	/* increments */
	float slope;		/* slope of line */
	float lastx = -1;	/* last x point plotted */
	float lasty = -1;	/* last y point plotted */
	int numdots = 0;	/* number of dots in this section */

	/* first, figure out increments for x and y */
	if (x2 == x1) {
	    xinc = 0.0;
	    yinc = (y2 - y1 > 0) ? dotspace : -dotspace;
	} else {
	    slope = ((float) y2 - y1) / ((float) x2 - x1);
	    xinc = dotspace / sqrt(1 + slope * slope) * sign(x2 - x1);
	    yinc = slope * xinc;
	}

	/* now draw the dotted line */
	/* we take into account where we last placed a dot */
	for (x = x1 + xinc * (1 - LATEX_left), y = y1 + yinc * (1 - LATEX_left);
	     (x2 - x) * xinc >= 0 && (y2 - y) * yinc >= 0;	/* same sign or zero */
	     lastx = x, x += xinc,
	     lasty = y, y += yinc)
	    numdots++;
	if (numdots == 1)
	    fprintf(gpoutfile, "\\put(%.2f,%.2f){%s}\n",
		    lastx, lasty, LATEX_DOT);
	else if (numdots > 0)
	    fprintf(gpoutfile, "\\multiput(%u,%u)(%.3f,%.3f){%u}{%s}\n",
		    x1, y1, xinc, yinc, numdots, LATEX_DOT);

	/* how much is left over, as a fraction of dotspace? */
	if (xinc != 0.0) {	/* xinc must be nonzero */
	    if (lastx >= 0)
		LATEX_left = ABS(x2 - lastx) / ABS(xinc);
	    else
		LATEX_left += ABS(x2 - x1) / ABS(xinc);
	} else
	    if (lasty >= 0)
		LATEX_left = ABS(y2 - lasty) / ABS(yinc);
	    else
		LATEX_left += ABS(y2 - y1) / ABS(yinc);
    }

    LATEX_needsdot = (LATEX_left > 0);

    LATEX_moved = FALSE;
}


static void
LATEX_flushdot()
{
    if (LATEX_needsdot)
	fprintf(gpoutfile, "\\put(%d,%d){%s}\n",
		LATEX_posx, LATEX_posy, LATEX_DOT);
    LATEX_needsdot = FALSE;
}


TERM_PUBLIC void
LATEX_arrow(
    unsigned int sx, unsigned int sy,
    unsigned int ex, unsigned int ey,
    int head)
{
    // This mostly converts the parameters to signed.
    best_latex_arrow(sx, sy, ex, ey, head);

    LATEX_posx = ex;
    LATEX_posy = ey;
}


static void
best_latex_arrow(
    int sx, int sy, int ex, int ey, /* start and end points */
    int head)
{
    int dx = ex - sx;
    int dy = ey - sy;
    float m;			/* slope of line */
    float arrowslope;		/* slope of arrow */
    float minerror = 0;		/* best-case error */
    struct vslope *slope;	/* one of the slopes */
    struct vslope *bestslope;	/* the slope with min error */

    /* We try to draw a real arrow (ie, \vector). If we can't get
       * a slope that is close, we draw a bent arrow.
     */

    if ((head & BOTH_HEADS) == BACKHEAD) {
	/* we need to draw only the backhead,
	  so we exchange start and stop coordinates */
	int tx = ex;
	int ty = ey;
	ex = sx;
	ey = sy;
	sx = tx;
	sy = ty;
	dx *= -1;
	dy *= -1;
	head &= ~BOTH_HEADS;
	head |= END_HEAD;
    }

    if (LATEX_mode == LATEX_PICT2E) {
	// pict2e has no restriction on slope
	int dx = ex - sx;
	int dy = ey - sy;
	float len = sqrt(dx * dx + dy * dy);
	dx /= len / 100.;
	dy /= len / 100.;
	// TODO: divide by GCD
	fprintf(gpoutfile, "\\put(%d,%d){\\%s(%d,%d){%d}}\n",
		sx, sy, head ? "vector" : "line",
		dx, dy,
		dx != 0 ? ABS(ex - sx) : ABS(ey - sy));
	if (head & BACKHEAD) {
	    fprintf(gpoutfile, "\\put(%d,%d){\\vector(%d,%d){0}}\n",
		    sx, sy,
		    -dx, -dy);
	}
	return;
    }

    if (dx == 0) {
	/* vertical arrow */
	fprintf(gpoutfile, "\\put(%d,%d){\\%s(0,%d){%d}}\n",
		sx, sy, head & END_HEAD ? "vector" : "line",
		sign(ey - sy), ABS(ey - sy));
	if (head & BACKHEAD) {
	    /* overlay a reversed arrow */
	    fprintf(gpoutfile, "\\put(%d,%d){\\vector(0,%d){0}}\n",
		    sx, sy, -1 * sign(ey - sy));
	}
    } else if (dy == 0) {
	/* horizontal arrow */
	fprintf(gpoutfile, "\\put(%d,%d){\\%s(%d,0){%d}}\n",
		sx, sy, head & END_HEAD ? "vector" : "line",
		sign(ex - sx), ABS(ex - sx));
	if (head & BACKHEAD) {
	    /* overlay a reversed arrow */
	    fprintf(gpoutfile, "\\put(%d,%d){\\vector(%d,0){0}}\n",
		    sx, sy, -1 * sign(ex - sx));
	}
    } else {
	/* Slanted arrow. We'll give it a try.
	 * we try to find the closest-slope arrowhead.
	 */
	bestslope = NULL;
	minerror = 0;		/* to shut up turbo C */
	m = ABS((float) dy / dx);	/* the slope we want */
	for (slope = LATEX_slopes; slope->dx != 0.0; slope++) {
	    /* find the slope of the arrow */
	    arrowslope = (float) slope->dy / slope->dx;
	    if (bestslope == NULL || ABS(m - arrowslope) < minerror) {
		minerror = ABS(m - arrowslope);
		bestslope = slope;
	    }
	}

	/* now we have the best slope arrow */
	/* maybe it's exactly the right slope! */
	if (minerror == 0.0) {	/* unlikely but possible */
	    fprintf(gpoutfile, "\\put(%d,%d){\\%s(%d,%d){%d}}\n",
		    sx, sy, head ? "vector" : "line",
		    bestslope->dx * sign(ex - sx), bestslope->dy * sign(ey - sy),
		    ABS(ex - sx));
	    if (head & BACKHEAD) {
		fprintf(gpoutfile, "\\put(%d,%d){\\vector(%d,%d){0}}\n",
			sx, sy,
			-1 * bestslope->dx * sign(ex - sx), -1 * bestslope->dy * sign(ey - sy));
	    }
	} else {
	    /* we draw the line the usual way, with thin lines */
	    LATEX_linesize();
	    if (LATEX_mode == LATEX_EMTEX) {
		EMTEX_solid_line(sx, ex, sy, ey);
	    } if (LATEX_mode == LATEX_EEPIC) {
		EEPIC_draw_line(sx, ex, sy, ey);
	    } else {
		LATEX_solid_line(sx, ex, sy, ey);
	    }

	    /* and then draw arrowheads (a short vector) there */
	    if (head & END_HEAD) {
		fprintf(gpoutfile, "\\put(%d,%d){\\vector(%d,%d){0}}\n",
			ex, ey,
			bestslope->dx * sign(ex - sx), bestslope->dy * sign(ey - sy));
	    }
	    if (head & BACKHEAD) {
		fprintf(gpoutfile, "\\put(%d,%d){\\vector(%d,%d){0}}\n",
			sx, sy,
			-1 * bestslope->dx * sign(ex - sx), -1 * bestslope->dy * sign(ey - sy));
	    }
	}
    }
}


TERM_PUBLIC void
LATEX_put_text(unsigned int x, unsigned int y, const char str[])
{
    static const char *justify[] = { "[l]", "", "[r]" };
    TBOOLEAN flag = FALSE;
    int i;

    /* ignore empty strings */
    if (str[0] == NUL)
	return;

    LATEX_endline();

    if (!latex_rotate)
    for (flag = FALSE, i = 0; str[i] && !flag;)
	flag = (str[i++] == '\\') && (str[i++] == '\\');

    fprintf(gpoutfile, "\\put(%d,%d)", x, y);
    if (latex_rotate && latex_angle)
    	fprintf (gpoutfile, "{\\rotatebox{%d}", latex_angle);
    if ((str[0] == '{') || (str[0] == '[')) {
	fprintf(gpoutfile, "{\\makebox(0,0)%s}\n", str);
    } else if (flag)
	fprintf(gpoutfile, "{\\makebox(0,0)%s{\\shortstack{%s}}}\n",
		justify[latex_justify], str);
    else
	fprintf(gpoutfile, "{\\makebox(0,0)%s{%s}}\n",
		justify[latex_justify], str);
    if (latex_rotate && latex_angle)
    	fprintf (gpoutfile, "}");
}


TERM_PUBLIC int
LATEX_justify_text(enum JUSTIFY mode)
{
    latex_justify = mode;
    return (TRUE);
}


TERM_PUBLIC int
LATEX_text_angle(int ang)
{
    /* we can't really write text vertically, but this will
       put the ylabel centred at the left of the plot, and
       then we'll make a \shortstack */
    /* latex_angle is not used elsewhere, so we use it for
       'real' text rotation using '\rotatebox' */
    latex_angle = ang;
    return (TRUE);
}


TERM_PUBLIC void
LATEX_fillbox(int style, unsigned int x1, unsigned int y1, unsigned
int width, unsigned int height)
{
    /* TODO: Something other than black/white */
    if ((style & 0xf) == FS_EMPTY)
	return;
    if ((style & 0xf) == FS_SOLID && (style >> 4) < 50)
	return;
    if ((style & 0xf) == FS_PATTERN && ((style >> 4) & 1) == 0)
	return;

    fprintf(gpoutfile, "\\put(%d,%d){\\rule{%gpt}{%gpt}}\n", x1, y1,
	    width*LATEX_UNIT, height*LATEX_UNIT);
}


TERM_PUBLIC int
LATEX_make_palette(t_sm_palette *palette)
{
    return 0;  /* we can do continuous colors */
}


TERM_PUBLIC void
LATEX_set_color(t_colorspec *colorspec)
{
    char colorstr[32];

    if (!latex_use_color)
	return;

    switch (colorspec->type) {
    case TC_RGB: {
	double r = (double)((colorspec->lt >> 16 ) & 255) / 255.;
	double g = (double)((colorspec->lt >> 8 ) & 255) / 255.;
	double b = (double)(colorspec->lt & 255) / 255.;

	snprintf(colorstr, sizeof(colorstr), "\\color[rgb]{%3.2f,%3.2f,%3.2f}\n", r, g, b);
	break;
    }
    case TC_LT: {
	int linetype = colorspec->lt;
	const char * colorname;

	if (linetype < 0 || !latex_use_color)
	    colorname = "black";
	else
	    colorname = LATEX_lt_colors[linetype % LATEX_num_colors];
	snprintf(colorstr, sizeof(colorstr), "\\color{%s}\n", colorname);
	break;
    }
    case TC_FRAC: {
	rgb_color color;

	rgb1_from_gray(colorspec->value, &color);
	snprintf(colorstr, sizeof(colorstr), "\\color[rgb]{%3.2f,%3.2f,%3.2f}", color.r, color.g, color.b);
    }
    }

    if (strcmp(colorstr, latex_color) != 0) {
	strcpy(latex_color, colorstr);
	if (latex_use_color)
	    fputs(colorstr, gpoutfile);
    }
}


/* EMTEX special routines */

static void
EMTEX_solid_line(int x1, int x2, int y1, int y2)
{
    /* emtex special solid line */
    if (LATEX_moved)
	fprintf(gpoutfile, "\\put(%d,%d){\\special{em:moveto}}\n", x1, y1);
    if ((x1 != x2) || (y1 != y2))
	fprintf(gpoutfile, "\\put(%d,%d){\\special{em:lineto}}\n", x2, y2);
    LATEX_posx = x2;
    LATEX_posy = y2;
    LATEX_moved = FALSE;
}


/* tpic special routines */

static int tpic_linewidth = 6;	/* min line thickness (in milli-inches) */
static double tpic_interval = 0.05;	/* min dot & dash intervals (in inches) */

static void
tpic_startline()
{				/* private */
    LATEX_inline = TRUE;
    tpic_pen(tpic_linewidth * LATEX_lw);
    LATEX_linecount = 0;
    LATEX_pushpath(LATEX_posx, LATEX_posy);
    return;
}

static void
tpic_endline()
{				/* private */
    double interval = 1;

    if (LATEX_inline) {
	tpic_scanpath();	/* draw actually */
	/* TODO: dash interval */
	interval = tpic_interval;
	switch (tpic_linetype) {
	case tpic_solid:
	    tpic_flush();
	    break;
	case tpic_dotted:
	    tpic_dottedflush(interval);
	    break;
	case tpic_dashed:
	    tpic_dashedflush(interval);
	    break;
	case tpic_dashed_sdot:	/* dashed with single dots in between */
	    tpic_dashedflush(interval);
	    tpic_scanpath();	/* draw again */
	    tpic_dottedflush(interval / 2);
	    break;
	case tpic_dashed_ddot:	/* dashed with double dots in between */
	    tpic_dashedflush(interval);
	    tpic_scanpath();	/* draw again */
	    tpic_dottedflush(interval / 3);
	    break;
	}
	LATEX_inline = FALSE;
    }
    return;
}

static void
tpic_scanpath()
{
    int i;

    for (i = 0; i < LATEX_linecount; i++)
	tpic_abspath(LATEX_path[i][0], LATEX_path[i][1]);
    return;
}

static void
tpic_fill(int style)
{
    int opt = style >> 4;

    // FIXME: need color code? gray level?

    // fill polygon
    switch (style & 0xf) {
    case FS_SOLID:
    case FS_TRANSPARENT_SOLID:
	tpic_shade((style >> 4) / 100.);
	break;
    case FS_PATTERN:
    case FS_TRANSPARENT_PATTERN:
	opt %= 4;
	if (opt == 0)
	    fputs("\\special{wh}", gpoutfile);
	else if (opt == 1)
	    tpic_shade(0.4);
	else if (opt == 2)
	    tpic_shade(0.2);
	else
	    fputs("\\special{bk}", gpoutfile);
	break;
    case FS_EMPTY:
	fputs("\\special{wh}", gpoutfile);
	break;
    case FS_DEFAULT:
    default:
	tpic_shade(0.2);
	break;
    }
}


TERM_PUBLIC void
TPIC_fillbox(int style,
		unsigned int x1, unsigned int y1,
		unsigned int width, unsigned int height)
{
    tpic_endline();
    tpic_fill(style);

    // outline box, must be closed
    tpic_path(x1, y1 - height);
    tpic_path(x1 + width, y1 - height);
    tpic_path(x1 + width, y1);
    tpic_path(x1, y1);
    tpic_path(x1, y1 - height);

    // fill polygon
    fputs("\\special{ip}%\n", gpoutfile);
}


TERM_PUBLIC void
TPIC_filled_polygon(int points, gpiPoint *corners)
{
    int i;

    tpic_endline();
    tpic_fill(corners->style);

    // outline polygon
    for (i = 0; i < points; i++)
	tpic_abspath(corners[i].x, corners[i].y);

    // make sure the path is closed
    if ((corners[0].x != corners[points - 1].x) || (corners[0].y != corners[points - 1].y))
	tpic_abspath(corners[0].x, term->ymax - corners[0].y);

    // fill polygon
    fputs("\\special{ip}%\n", gpoutfile);
}

/* private: draw lines */

static void
tpic_abspath(unsigned int x, unsigned int y)
{
    tpic_path(x, -y);
    fputs("%\n", gpoutfile);
    return;
}

/* private: tpic primitive functions */

static void
tpic_path(int x, int y)
{
    // need to handle coordinate transform only here
    fprintf(gpoutfile, "\\special{pa %d %d}",
	(int) (x / (TPIC_UNIT * DOTS_PER_INCH)),
	(int) (y / (TPIC_UNIT * DOTS_PER_INCH)));
    return;
}

static void
tpic_flush()
{
    fputs("\\special{fp}%\n", gpoutfile);
    return;
}

static void
tpic_arc(int radius)
{
    /* actually, draw a full circle */
    fprintf(gpoutfile, "\\special{ar 0 0 %d %d 0 7}", radius, radius);
    return;
}

static void
tpic_shade(double grayscale)
{
    fprintf(gpoutfile, "\\special{sh %f}", grayscale);
    return;
}

static void
tpic_pen(int thickness)
{
    fprintf(gpoutfile, "\\special{pn %d}", thickness);
    return;
}

static void
tpic_dottedflush(double interval)
{
    fprintf(gpoutfile, "\\special{dt %f}%%\n", interval);
    return;
}

static void
tpic_dashedflush(double interval)
{
    fprintf(gpoutfile, "\\special{da %f}%%\n", interval);
    return;
}


/* EEPIC special routines */

static void
EEPIC_draw_line(int x1, int x2, int y1, int y2)
{
    if (!LATEX_inline) {
	LATEX_inline = TRUE;

	/* Start a new line. This depends on line type */
	fprintf(gpoutfile, "%s(%u,%u)",
		EEPIC_line,
		x1, y1);
	LATEX_linecount = 1;
    } else {
	/* Even though we are in middle of a path,
	 * we may want to start a new path command.
	 * If they are too long then latex will choke.
	 */
	if (LATEX_linecount++ >= LATEX_LINEMAX) {
	    fprintf(gpoutfile, "\n%s(%u,%u)",
		    EEPIC_line,
		    x1, y1);
	    LATEX_linecount = 1;
	}
    }
    fprintf(gpoutfile, "(%u,%u)", x2, y2);
}


static void
EEPIC_fill(int style)
{
    int opt = style >> 4;

    /* TODO: According to the documentation, we could use
       \texture commands to change the filling of \shade */
    // fill polygon
    switch (style & 0xf) {
    case FS_SOLID:
    case FS_TRANSPARENT_SOLID:
	/* We allow at least black, white and gray fills */
	fputs("\\blacken", gpoutfile);
	break;
    case FS_PATTERN:
    case FS_TRANSPARENT_PATTERN:
	opt %= 3;
	if (opt == 0)
	    fputs("\\whiten", gpoutfile);
	else if (opt == 1)
	    fputs("\\shade", gpoutfile);
	else
	    fputs("\\blacken", gpoutfile);
	break;
    case FS_EMPTY:
	fputs("\\whiten", gpoutfile);
	break;
    case FS_DEFAULT:
    default:
	fputs("\\shade", gpoutfile);
	break;
    }
}


TERM_PUBLIC void
EEPIC_fillbox(int style,
		unsigned int x1, unsigned int y1,
		unsigned int width, unsigned int height)
{
    LATEX_endline();

    // fill polygon
    EEPIC_fill(style);
    // outline box
    fprintf(gpoutfile, "\\path(%d,%d)(%d,%d)(%d,%d)(%d,%d)(%d,%d)\n",
	x1, y1,
	x1 + width, y1,
	x1 + width, y1 + height,
	x1, y1 + height,
	x1, y1);

}


TERM_PUBLIC void
EEPIC_filled_polygon(int points, gpiPoint *corners)
{
    int i;

    LATEX_endline();

    // fill polygon
    EEPIC_fill(corners->style);
    // outline polygon
    fprintf(gpoutfile, "\\path(%d,%d)", corners[0].x, corners[0].y);
    for (i = 1; i < points; i++)
	fprintf(gpoutfile, "(%d,%d)", corners[i].x, corners[i].y);
    fputs("\n", gpoutfile);
}


/* PICT2E special routines */

static void
PICT2E_endline(void)
{
    if (LATEX_inline) {
	int i;

	if (LATEX_linecount == 2)
	    fputs("\\Line", gpoutfile);
	else
	    fputs("\\polyline", gpoutfile);
	for (i = 0; i < LATEX_linecount; i++)
	    fprintf(gpoutfile, "(%d,%d)", LATEX_path[i][0], LATEX_path[i][1]);
	fputs("\n", gpoutfile);

	LATEX_inline = FALSE;
	LATEX_linecount = 0;
    }
}


static void
PICT2E_solid_line(int x1, int x2, int y1, int y2)
{
    if (!LATEX_inline)
	LATEX_pushpath(x1, y1);

    LATEX_inline = TRUE;
    LATEX_pushpath(x2, y2);

    if (LATEX_linecount == LATEX_LINEMAX) {
	PICT2E_endline();
	LATEX_pushpath(x2, y2);
    }

    LATEX_posx = x2;
    LATEX_posy = y2;
}

typedef enum  { pict2e_no_fill, pict2e_fill, pict2e_fill_and_restore} pict2e_fill_cmds;

static int
PICT2E_fill(int style)
{
    TBOOLEAN fill = pict2e_fill;
    int opt = style >> 4;

    switch (style & 0xf) {
    case FS_SOLID:
    case FS_TRANSPARENT_SOLID:
	if (latex_use_color) {
	    if (opt != 100) {
		fputs("\\colorlet{pict2ecol}{.}", gpoutfile); // save current color
		fprintf(gpoutfile, "\\color{.!%d}\n", opt);
		fill = pict2e_fill_and_restore;
	    } else {
		fill = pict2e_fill;
	    }
	} else if (opt < 50) {
	    fill = pict2e_no_fill;
	}
	break;
    case FS_PATTERN:
    case FS_TRANSPARENT_PATTERN:
	if (latex_use_color) {
	    fputs("\\colorlet{pict2ecol}{.}", gpoutfile); // save current color
	    opt %= 4;
	    if (opt == 0)
		fprintf(gpoutfile, "\\color{white}\n", opt);
	    else if (opt == 1)
		fprintf(gpoutfile, "\\color{.!50}\n", opt);
	    else if (opt == 2)
		fprintf(gpoutfile, "\\color{.!20}\n", opt);
	    else if (opt == 3)
		fprintf(gpoutfile, "\\color{black}\n", opt);
	    fill = pict2e_fill_and_restore;
	} else {
	    if ((opt % 2) == 0)
		fill = pict2e_no_fill;
	    else
		fill = pict2e_fill;
	}
	break;
    case FS_EMPTY:
	if (latex_use_color) {
	    fputs("\\colorlet{pict2ecol}{.}", gpoutfile); // save current color
	    fprintf(gpoutfile, "\\color{white}\n", opt);
	    fill = pict2e_fill_and_restore;
	} else {
	    fill = pict2e_no_fill;
	}
	break;
    case FS_DEFAULT:
    default:
	/* use currently active color */
	fill = pict2e_fill;
	break;
    }
    return fill;
}


TERM_PUBLIC void
PICT2E_fillbox(int style,
		unsigned int x1, unsigned int y1,
		unsigned int width, unsigned int height)
{
    int ret;

    PICT2E_endline();

    if ((ret = PICT2E_fill(style)) == pict2e_no_fill)
	return;

    // outline box, must be closed
    fprintf(gpoutfile, "\\polygon*(%d,%d)(%d,%d)(%d,%d)(%d,%d)(%d,%d)\n",
	x1, y1,
	x1 + width, y1,
	x1 + width, y1 + height,
	x1, y1 + height,
	x1, y1);

    if (latex_use_color && (ret == pict2e_fill_and_restore))
	fputs("\\color{pict2ecol}\n", gpoutfile); // restore color
}


TERM_PUBLIC void
PICT2E_filled_polygon(int points, gpiPoint *corners)
{
    int i, ret;

    PICT2E_endline();

    if ((ret = PICT2E_fill(corners->style)) == pict2e_no_fill)
	return;

    fprintf(gpoutfile, "\\polygon*(%d,%d)", corners[0].x, corners[0].y);
    for (i = 0; i < points; i++)
	fprintf(gpoutfile, "(%d,%d)", corners[i].x, corners[i].y);
    // make sure the path is closed
    if ((corners[0].x != corners[points - 1].x) || (corners[0].y != corners[points - 1].y))
	fprintf(gpoutfile, "(%d,%d)", corners[0].x, corners[0].y);
    fputs("\n", gpoutfile);

    if (latex_use_color && (ret == pict2e_fill_and_restore))
	fputs("\\color{pict2ecol}\n", gpoutfile); // restore color
}

#endif /* TERM_BODY */
#endif /* TERM_PROTO_ONLY */

#ifdef TERM_TABLE

TERM_TABLE_START(latex_driver)
    "latex", "LaTeX picture environment (latex/emtex/tpic/eepic/pict2e variants)",
    LATEX_XMAX, LATEX_YMAX, LATEX_VCHAR, LATEX_HCHAR,
    LATEX_VTIC, LATEX_HTIC, LATEX_options, LATEX_init, LATEX_reset,
    LATEX_text, null_scale, LATEX_graphics, LATEX_move, LATEX_vector,
    LATEX_linetype, LATEX_put_text, LATEX_text_angle,
    LATEX_justify_text, LATEX_point, LATEX_arrow, set_font_null,
    NULL, /* pointsize */
    TERM_IS_LATEX | TERM_CAN_DASH | TERM_MONOCHROME, /* flags */
    NULL, NULL, /* suspend, resume */
    LATEX_fillbox, LATEX_linewidth,
#ifdef USE_MOUSE
    NULL, NULL, NULL, NULL, NULL,
#endif
    LATEX_make_palette, 0,
    LATEX_set_color,
    0 /* filled_polygon */,
    0, /* image */
    0, 0, 0, /* enhanced text */
    0, /* layer */
    0, /* path */
    0.0, /* scale (unused) */
    0, /* hypertext */
#ifdef EAM_BOXED_TEXT
    0,
#endif
    0,
    LATEX_dashtype
TERM_TABLE_END(latex_driver)

#undef LAST_TERM
#define LAST_TERM latex_driver

#endif /* TERM_TABLE */


#ifdef TERM_HELP
START_HELP(latex)
"1 latex",
"?commands set terminal latex",
"?set terminal latex",
"?set term latex",
"?terminal latex",
"?term latex",
"?latex",
"?commands set terminal emtex",
"?set terminal emtex",
"?set term emtex",
"?terminal emtex",
"?term emtex",
"?emtex",
"?commands set terminal tpic",
"?set terminal tpic",
"?set term tpic",
"?terminal tpic",
"?term tpic",
"?tpic",
"?commands set terminal eepic",
"?set terminal eepic",
"?set term eepic",
"?terminal eepic",
"?term eepic",
"?eepic",
"?commands set terminal pict2e",
"?set terminal pict2e",
"?set term pict2e",
"?terminal pict2e",
"?term pict2e",
"?pict2e",
" The `latex` terminal supports the LaTeX picture environment, including",
" different variants which overcome the limitations of the original concerning",
" line drawing and area filling.",
"",
" Syntax:",
"       set terminal latex {legacy | emtex | tpic | eepic | pict2e}",
"                    {default | {courier|roman} {<fontsize>}}",
"                    {size <XX>{unit}, <YY>{unit}} {rotate | norotate}",
"                    {color | monochrome}",
"                    {small | tiny | normal}",
"",
" The `legacy` option selects the original picture environment, which has some",
" rather severe limitations. `emtex` uses emTeX \\special commands to overcome",
" some of them. `tpic` uses tpic \\specials. These need to be supported by",
" your DVI driver. emTeX and tpic \\specials are supported by dvips and",
" xelatex, but not pdflatex. `eepic` uses macros of the `eepic` and `epic`",
" package. These also emit tpic \\specials. Alternatively, you can use it",
" with the `bxeepic` and `pict2e` packages. `pict2e` uses the LaTeX2e variant",
" of the picture environment directly.  You need to add \"\\usepackage{pict2e}\"",
" to your file. This is the recommended and default variant.",
"",
" By default the plot will inherit font settings from the embedding document.",
" You have the option of forcing either Courier (cmtt) or Roman (cmr) fonts",
" instead. In this case you may also specify a fontsize.",
" Unless your driver is capable of building fonts at any size (e.g. dvips),",
" stick to the standard 10, 11 and 12 point sizes.",
" METAFONT users beware: METAFONT does not like odd sizes.",
"",
" All drivers for LaTeX offer a special way of controlling text positioning:",
" If any text string begins with '{', you also need to include a '}' at the",
" end of the text, and the whole text will be centered both horizontally and",
" vertically.  If the text string begins with '[', you need to follow this with",
" a position specification (up to two out of t,b,l,r), ']{', the text itself,",
" and finally '}'.  The text itself may be anything LaTeX can typeset as an",
" LR-box.  '\\rule{}{}'s may help for best positioning.",
"",
" Points, among other things, are drawn using the LaTeX commands \"\\Diamond\" and",
" \"\\Box\".  These commands no longer belong to the LaTeX2e core; they are included",
" in the latexsym package, which is part of the base distribution and thus part",
" of any LaTeX implementation.  Please do not forget to use this package.",
" Other point types use symbols from the amssymb package.",
"",
" The default size for the plot is 5 inches by 3 inches. The `size` option",
" changes this to whatever the user requests. By default the X and Y sizes",
" are taken to be in inches, but other units are possible (currently only cm).",
"",
" `rotate` will enable true rotated text. Otherwise, rotated text at 90 degrees",
" will be typeset with letters stacked above each other. If you use this option",
" you must include \\usepackage{graphicx} in the preamble.",
"",
" `color` causes gnuplot to produce \\color{...} commands so that the graphs are",
" colored. Using this option, you must include \\usepackage{color} (or xcolor)",
" in the preamble of your latex document.",
"",
" Examples:",
" About label positioning:",
" Use gnuplot defaults (mostly sensible, but sometimes not really best):",
"        set title '\\LaTeX\\ -- $ \\gamma $'",
" Force centering both horizontally and vertically:",
"        set label '{\\LaTeX\\ -- $ \\gamma $}' at 0,0",
" Specify own positioning (top here):",
"        set xlabel '[t]{\\LaTeX\\ -- $ \\gamma $}'",
" The other label -- account for long ticlabels:",
"        set ylabel '[r]{\\LaTeX\\ -- $ \\gamma $\\rule{7mm}{0pt}}'"
END_HELP(latex)
#endif /* TERM_TABLE */
